package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"HealthCareSystem/graphql/generated"
	"HealthCareSystem/graphql/model"
	"HealthCareSystem/services"
	"context"
	"fmt"
	"log"
	"strconv"

	"golang.org/x/crypto/bcrypt"
)


func NewResolver(userService *services.UserService) *Resolver {
    return &Resolver{
        userService: userService,
    }
}

// HashPassword hashes the given password
func HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*services.User, error) {
	
	// Hash the password
    passwordHash, err := HashPassword(input.Password)
    if err != nil {
        return nil, fmt.Errorf("error hashing password: %v", err)
    }

	// Prepare user input
    userInput := services.UserInput{
        Username:    input.Username,
        PasswordHash: passwordHash,
        Email:       input.Email,
        Phone:       input.Phone,
        Role:        services.UserRole(input.Role),
    }

	// Call the user service to create the user
    user, err := r.userService.CreateUser(ctx, userInput)
    if err != nil {
        return nil, fmt.Errorf("error creating user: %v", err)
    }

    return user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input services.UpdateUserInput) (*services.User, error) {
	// Converting the string ID to int.
	userID, err := strconv.Atoi(id)

	if err != nil {
		return nil, fmt.Errorf("invalid user id: %v", err)
	}

	// Calling the userservice updater method.
	user, err := r.userService.UpdateUser(ctx, userID, input)
	if err != nil {
		return nil, fmt.Errorf("failed to update user: %v", err)
	}
	return user, nil
}

// UpdatePassword is the resolver for the updatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, id string, password string) (bool, error) {
	// Hash the password

    passwordHash, err := HashPassword(password)
    if err != nil {
        return false, fmt.Errorf("error hashing password: %v", err)
    }

	userId, err := strconv.Atoi(id)

	updated, err := r.userService.UpdatePassword(ctx, userId, passwordHash)

	if err != nil {
		return false, err
	}

	return updated, err
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*services.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// UserByEmail is the resolver for the userByEmail field.
func (r *queryResolver) UserByEmail(ctx context.Context, email string) (*services.User, error) {
	panic(fmt.Errorf("not implemented: UserByEmail - userByEmail"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*services.User, error) {
	limitValue := 10
    offsetValue := 0
    
    if limit != nil {
        limitValue = *limit
    }
    if offset != nil {
        offsetValue = *offset
    }

    // Call the GetAllUsers method from UserService
    users, err := r.userService.GetAllUsers(ctx, limitValue, offsetValue)
    if err != nil {
		log.Printf("Error fetching users: %v", err)
        return nil, fmt.Errorf("error fetching users: %v", err)
    }

	log.Printf("Fetched users: %+v", users)

    return users, nil
	// panic(fmt.Errorf("not implemented: Users - users"))
}

// UsersCount is the resolver for the usersCount field.
func (r *queryResolver) UsersCount(ctx context.Context) (int, error) {
	panic(fmt.Errorf("not implemented: UsersCount - usersCount"))
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *services.User) (string, error) {
	panic(fmt.Errorf("not implemented: ID - id"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
