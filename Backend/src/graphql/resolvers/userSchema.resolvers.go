package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"HealthCareSystem/graphql/generated"
	"HealthCareSystem/graphql/model"
	"HealthCareSystem/middleware"
	"HealthCareSystem/services"
	"HealthCareSystem/utils"
	"context"
	"fmt"
	"log"
	"os"
	"strconv"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*services.User, error) {
	// Hash the password
	passwordHash, err := utils.HashPassword(input.Password)
	if err != nil {
		return nil, fmt.Errorf("error hashing password: %v", err)
	} else {
		println("CreateUser - password hashed successfully")
	}

	// Prepare user input
	userInput := services.UserInput{
		Username:     input.Username,
		PasswordHash: passwordHash,
		Email:        input.Email,
		Phone:        input.Phone,
		Role:         services.UserRole(input.Role),
	}

	// Call the user service to create the user
	user, err := r.userService.CreateUser(ctx, userInput)
	if err != nil {
		fmt.Printf("Error creating user - userService: %v", err)
		return nil, fmt.Errorf("error creating user: %v", err)
	} else {
		println("User created successfully - userService")
	}

	token, err := middleware.CreateToken(user.ID)
	if err != nil {
		return nil, fmt.Errorf("error creating token: %v", err)
	}

	updateTokenInput := services.UpdateUserTokenInput{
		ID:    user.ID,
		Token: token,
	}

	// Generate a token for the new user

	// Ading the token to the user.
	user, err = r.userService.UpdateUserToken(ctx, updateTokenInput)
	if err != nil {
		return nil, fmt.Errorf("error adding token to db: %v", err)
	}

	return user, err
}

// SignInUser is the resolver for the signInUser field.
func (r *mutationResolver) SignInUser(ctx context.Context, input model.SignInInput) (*services.User, error) {
	user, err := r.userService.GetUserByEmail(ctx, input.Email)
	if err != nil {
		return nil, fmt.Errorf("errogettingUserByEmail: %v", err)
	} else {
		fmt.Printf("Successfully got user by email:%v", user)
	}

	// Checking for password
	println("Checking passwordmatch")

	fmt.Printf("Hashed password: %v\n", user.PasswordHash)
	fmt.Printf("user password: %v\n", input.Password)
	os.Stdout.Sync()

	err = utils.CheckPassword(input.Password, user.PasswordHash)
	if err != nil {
		println("passwords do not match")
		return nil, err
	}

	fmt.Printf("passowrds match - updating user token ...: %v ", user)

	token, err := middleware.CreateToken(user.ID)
	if err != nil {
		return nil, fmt.Errorf("error creating token: %v", err)
	}

	updateTokenInput := services.UpdateUserTokenInput{
		ID:    user.ID,
		Token: token,
	}

	user, err = r.userService.UpdateUserToken(ctx, updateTokenInput)
	if err != nil {
		return nil, fmt.Errorf("error adding token to db: %v", err)
	}

	return user, err
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, input services.UpdateUserInput) (*services.User, error) {
	// Converting the string ID to int.
	userID, err := strconv.Atoi(id)

	if err != nil {
		return nil, fmt.Errorf("invalid user id: %v", err)
	}

	// Calling the userservice updater method.
	user, err := r.userService.UpdateUser(ctx, userID, input)
	if err != nil {
		return nil, fmt.Errorf("failed to update user: %v", err)
	}
	return user, err
}

// UpdatePassword is the resolver for the updatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, id string, password string, token string) (bool, error) {
	// Hash the password

	passwordHash, err := utils.HashPassword(password)
	if err != nil {
		return false, fmt.Errorf("error hashing password: %v", err)
	}

	userId, err := strconv.Atoi(id)
	if err != nil {
		return false, fmt.Errorf("failed converting id to number: %v", err)
	}

	updated, err := r.userService.UpdatePassword(ctx, userId, passwordHash)

	if err != nil {
		return false, err
	}

	return updated, err
}

// DELETE is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, email string, token string) (bool, error) {
	// Get user ID from the token
	userId, err := middleware.GetUserIDFromToken(token)
	if err != nil {
		return false, fmt.Errorf("error getting user ID from token: %v", err)
	} else {
		fmt.Printf("got id from token: %v", userId)
	}

	// getting user by email.
	user, err := r.userService.GetUserByEmail(ctx, email)
	if err != nil {
		return false, fmt.Errorf("error : getting user by email: %v", err)
	}

	// Check if the stored token matches the given token
	if user.Token != token {
		return false, fmt.Errorf("unaithorized: token is expired")
	}

	// Call the service to delete the user
	deleted, err := r.userService.DeleteUser(ctx, userId)
	if err != nil {
		return false, fmt.Errorf("could not delete user: %v", err)
	}

	// Return the result of deletion
	return deleted, nil
}

// Getting a user by Id.
func (r *queryResolver) User(ctx context.Context, id string) (*services.User, error) {
	userId, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("error converting to string: %v", err)
	}

	user, err := r.userService.GetUserByID(ctx, userId)

	if err != nil {
		return nil, fmt.Errorf("error gettuserbyid: %v", err)
	}

	return user, err
}

// Retrieving email by user
func (r *queryResolver) UserByEmail(ctx context.Context, email string) (*services.User, error) {
	user, err := r.userService.GetUserByEmail(ctx, email)
	if err != nil {
		return nil, fmt.Errorf("error gettinguserbyemail: %v", err)
	}

	return user, err
}

// Getting all the users
func (r *queryResolver) Users(ctx context.Context, limit *int, offset *int) ([]*services.User, error) {
	limitValue := 10
	offsetValue := 0

	if limit != nil {
		limitValue = *limit
	}
	if offset != nil {
		offsetValue = *offset
	}

	// Call the GetAllUsers method from UserService
	users, err := r.userService.GetAllUsers(ctx, limitValue, offsetValue)
	if err != nil {
		log.Printf("Error fetching users: %v", err)
		return nil, fmt.Errorf("error fetching users: %v", err)
	}

	log.Printf("Fetched users: %+v", users)

	return users, err
	// panic(fmt.Errorf("not implemented: Users - users"))
}

// Getting the count of all the users
func (r *queryResolver) UsersCount(ctx context.Context) (int, error) {
	count, err := r.userService.GetUsersCount(ctx)
	if err != nil {
		return 0, fmt.Errorf("error gettingusercount: %v", err)
	}

	return count, err
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *services.User) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("user object is nil")
	}
	return strconv.Itoa(obj.ID), nil
}

// Token is the resolver for the token field.
func (r *updateUserInputResolver) Token(ctx context.Context, obj *services.UpdateUserInput, data *string) error {
	panic(fmt.Errorf("not implemented: Token - token"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

// UpdateUserInput returns generated.UpdateUserInputResolver implementation.
func (r *Resolver) UpdateUserInput() generated.UpdateUserInputResolver {
	return &updateUserInputResolver{r}
}

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type updateUserInputResolver struct{ *Resolver }
